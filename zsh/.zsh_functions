#!/usr/bin/env zsh
# vim: awa:sts=4:ts=4:sw=4:et:cin:fdm=manual:tw=120:ft=zsh

zmodload zsh/zpty

teletype() {
    # Applications will often attempt to detect if output is going to a TTY (terminal) or a file.  If the application
    #  cannot specify --color=always it will assume it's destination is a file.  The following code creates a virtual
    #  zsh tty and launches the application within that context.  The application then knows its outputting to a TTY
    #  (terminal) and will not strip the embedded color codes.
    zpty pty-${UID} ${1+$@}
    if [[ ! -t 1 ]];then
        setopt local_traps
        trap '' INT
    fi
    zpty -r pty-${UID}
    zpty -d pty-${UID}
}

goclean() {
    local pkg=$1
    local ost
    local cnt

    # Clean removes object files from package source directories (ignore error)
    echo "go clean -i $pkg &>/dev/null"
    go clean -i $pkg &>/dev/null

    # Set local variables
    [[ "$(uname -m)" == "x86_64" ]] && ost="$(uname)";ost="${ost:l}_amd64" && cnt="${pkg//[^\/]}"
    # bash lowercase: ost="${ost,,}_amd64", zsh lowercase: ost="${ost:l}_amd64"
    #[[ "$(uname -m)" == "x86_64" ]] && ost="$(uname)";ost="${ost,,}_amd64" && cnt="${pkg//[^\/]}"
    #echo "ost: $ost, cnt: $cnt"

    # Delete the source directory and compiled package directory(ies)
    if (( ${#cnt} == 2 )) then
        echo "rm -rf \"${GOPATH%%:*}/src/${pkg%/*}\""
        rm -rf "${GOPATH%%:*}/src/${pkg%/*}"
        echo "rm -rf \"${GOPATH%%:*}/pkg/${ost}/${pkg%/*}\""
        rm -rf "${GOPATH%%:*}/pkg/${ost}/${pkg%/*}"
    elif (( ${#cnt} > 2 )) then
        echo "rm -rf \"${GOPATH%%:*}/src/${pkg%/*/*}\""
        rm -rf "${GOPATH%%:*}/src/${pkg%/*/*}"
        echo "rm -rf \"${GOPATH%%:*}/pkg/${ost}/${pkg%/*/*}\""
        rm -rf "${GOPATH%%:*}/pkg/${ost}/${pkg%/*/*}"
    fi
    unset pkg, ost, cnt
}

de-duplicate-zsh-paths() {
    # This ensures that duplicate paths are not persisted to the PATH environment
    #  variable regaurdless of how many times source .zshrc is executed
    typeset -U PATH
    # Shouldn't have to keep track of NIX paths but... oh well!
    typeset -U NIX_PATH
    typeset -U NIX_PROFILES
}

set-cscope() {
    eval `find . -name '*.c' -o -name '*.cpp' -o -name '*.h' -o -name '*.hpp' > ./cscope.files`
    eval `cscope -b`
}

dev() {
    cd $HOME/dev/$1
}

get-login-info() {
    if [[ -e "$HOME/scripts/login_info.py" ]] then
        python3 $HOME/scripts/login_info.py
    fi
}

get-network-info() {
    if [[ -e "$HOME/scripts/network_info.py" ]] then
        python3 $HOME/scripts/network_info.py
    fi
}

get-weather-info() {
    if [[ -e "$HOME/scripts/weather_info.py" ]] then
        python3 $HOME/scripts/weather_info.py
    fi
}

get-full-weather-info() {
    if [[ -e "$HOME/scripts/weather_info.py" ]] then
        python3 $HOME/scripts/weather_info.py --full-report
    fi
}

uuid-generator() {
    if [[ ! $(uuidgen --verbose > /dev/null 2>&1) ]] then
        echo `uuidgen | tr -d '-' | tr '[:upper:]' '[:lower:]'`
    else
        echo `uuidgen --random | sed 's/-//g'`
    fi
}

abs-path() {
    [ $# -gt 0 ] && local dir_="$1" || local dir_="$(pwd -P)"
    printf "\e[32m%s\e[0m\e[1m: %s\e[0m\n" "realpath" "$(realpath -LPe $dir_)"
}

get-dirsize() {
    [ $# -gt 0 ] && local dir_="$1" || local dir_="$(pwd -P)"
    du -hcs "$dir_" | sed -n '1p;$p' | awk -f $HOME/scripts/dirsize.awk
}

get-active-network-interface() {
    ip route get 1.1.1.1 | awk '{ if (NR == 1) { print $5; } }'
}

get-confirmation() {
    read "RESPONSE?$1. Continue [Y/n]? "
    if [[ ( -z $RESPONSE || $RESPONSE =~ ^[Yy].*$ ) ]] then
        echo 1;
    else
        echo 0;
    fi
}

set-tab-color() {
    if [ -e "$HOME/.zsh_color" ]; then
        echo $(head -n 1 $HOME/.zsh_color) | python3 $HOME/scripts/set_tab_color.py
    elif [ -e "$HOME/.bash_color" ]; then
        echo $(head -n 1 $HOME/.bash_color) | python3 $HOME/scripts/set_tab_color.py
    fi
}

man() {
    LESS_TERMCAP_md=$'\e[01;31m' \
    LESS_TERMCAP_me=$'\e[0m' \
    LESS_TERMCAP_se=$'\e[0m' \
    LESS_TERMCAP_so=$'\e[01;44;33m' \
    LESS_TERMCAP_ue=$'\e[0m' \
    LESS_TERMCAP_us=$'\e[01;32m' \
    command man "$@"
}

ssh-vpn() {
    ssh -F $HOME/tools/algo/configs/$1/ssh_config $1
}

restart() {
    let confirmation=$(get-confirmation "Reboot now")
    if (( $confirmation == 1 )); then
        echo "Rebooting now ...1..2..3..."
        if [[ "$(uname -s)" == "Darwin" ]] then
            # Shows no confirmation dialog
            #osascript -e 'tell app "System Events" to restart'
            # Shows a confirmation dialog
            osascript -e 'tell app "loginwindow" to «event aevtrrst»'
        else
            sudo systemctl reboot
        fi
    else
        echo "Not rebooting now..."
    fi
}

shutoff() {
    let confirmation=$(get-confirmation "Shutdown now")
    if (( $confirmation == 1 )); then
        echo "Shutting down now ...1..2..3..."
        if [[ "$(uname -s)" == "Darwin" ]] then
            # Shows no confirmation dialog
            #osascript -e 'tell app "System Events" to shut down'
            # Shows a confirmation dialog
            osascript -e 'tell app "loginwindow" to «event aevtrsdn»'
        else
            sudo systemctl halt
        fi
    else
        echo "Not shutting down now..."
    fi
}

